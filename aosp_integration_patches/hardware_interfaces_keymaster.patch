diff --git a/keymaster/4.0/vts/functional/Android.bp b/keymaster/4.0/vts/functional/Android.bp
index a7be660c4..dd91e9089 100644
--- a/keymaster/4.0/vts/functional/Android.bp
+++ b/keymaster/4.0/vts/functional/Android.bp
@@ -31,9 +31,11 @@ cc_test {
         "VerificationTokenTest.cpp",
         "keymaster_hidl_hal_test.cpp",
     ],
+    shared_libs: [
+        "libcrypto",
+    ],
     static_libs: [
         "android.hardware.keymaster@4.0",
-        "libcrypto_static",
         "libkeymaster4support",
         "libkeymaster4vtstest",
     ],
diff --git a/keymaster/4.0/vts/functional/keymaster_hidl_hal_test.cpp b/keymaster/4.0/vts/functional/keymaster_hidl_hal_test.cpp
index 476eed8b1..3b2cdb641 100644
--- a/keymaster/4.0/vts/functional/keymaster_hidl_hal_test.cpp
+++ b/keymaster/4.0/vts/functional/keymaster_hidl_hal_test.cpp
@@ -29,6 +29,9 @@
 
 #include <cutils/properties.h>
 
+#include <openssl/hmac.h>
+#include <openssl/sha.h>
+
 #include <keymasterV4_0/attestation_record.h>
 #include <keymasterV4_0/key_param_output.h>
 #include <keymasterV4_0/openssl_utils.h>
@@ -1079,20 +1082,229 @@ TEST_P(SigningOperationsTest, RsaPaddingNoneDoesNotAllowOther) {
  * presented.
  */
 TEST_P(SigningOperationsTest, NoUserConfirmation) {
-    if (SecLevel() == SecurityLevel::STRONGBOX) return;
     ASSERT_EQ(ErrorCode::OK, GenerateKey(AuthorizationSetBuilder()
-                                             .RsaSigningKey(1024, 65537)
+                                             .RsaSigningKey(2048, 65537)
+                                             .Digest(Digest::NONE)
+                                             .Padding(PaddingMode::NONE)
+                                             .Authorization(TAG_NO_AUTH_REQUIRED)
+                                             .Authorization(TAG_TRUSTED_CONFIRMATION_REQUIRED)));
+
+    const string message = "12345678901234567890123456789012";
+    EXPECT_EQ(ErrorCode::OK,
+              Begin(KeyPurpose::SIGN,
+                    AuthorizationSetBuilder().Digest(Digest::NONE).Padding(PaddingMode::NONE)));
+    string signature;
+    EXPECT_EQ(ErrorCode::NO_USER_CONFIRMATION, Finish(message, &signature));
+}
+
+/*
+ * SigningOperationsTest.TrustedConfirmationRequired
+ *
+ * Verifies that keymaster performs signing operations for keys with
+ * TRUSTED_CONFIRMATION_REQUIRED and a valid confirmation token
+ * presented.
+ */
+TEST_P(SigningOperationsTest, TrustedConfirmationRequired) {
+    ASSERT_EQ(ErrorCode::OK, GenerateKey(AuthorizationSetBuilder()
+                                             .RsaSigningKey(2048, 65537)
+                                             .Digest(Digest::NONE)
+                                             .Padding(PaddingMode::NONE)
+                                             .Authorization(TAG_NO_AUTH_REQUIRED)
+                                             .Authorization(TAG_TRUSTED_CONFIRMATION_REQUIRED)));
+
+    const string conf_token = "confirmation token";
+    const string message = "12345678901234567890123456789012";
+    string signature;
+    
+    std::vector<uint8_t> input;
+    input.insert(input.end(), conf_token.begin(), conf_token.end());
+    input.insert(input.end(), message.begin(), message.end());
+    
+    std::vector<uint8_t> macKey(32, 0);
+    std::array<uint8_t, 32> hash;
+    unsigned int hashLen = 0;
+    
+    auto result = ::HMAC(EVP_sha256(), macKey.data(), macKey.size(), input.data(), input.size(), hash.data(), &hashLen);
+    EXPECT_TRUE(result != nullptr);
+
+    std::vector<uint8_t> confToken(hash.begin(), hash.end());
+    
+    EXPECT_EQ(ErrorCode::OK,
+              Begin(KeyPurpose::SIGN,
+                    AuthorizationSetBuilder().Digest(Digest::NONE).Padding(PaddingMode::NONE)));
+    
+    AuthorizationSet out_params;
+    string output;
+    string retText;
+    
+    EXPECT_EQ(ErrorCode::OK, Finish(op_handle_, AuthorizationSetBuilder().Authorization(TAG_CONFIRMATION_TOKEN,HidlBuf(confToken)), message, signature,
+                             &out_params, &output));
+    CheckedDeleteKey();
+}
+
+/*
+ * SigningOperationsTest.NoUserConfirmation2_FailureSuccess
+ *
+ * Verifies that keymaster validates failure and success signing operations for key with
+ * TRUSTED_CONFIRMATION_REQUIRED and a valid confirmation token
+ * presented.
+ */
+
+TEST_P(SigningOperationsTest, NoUserConfirmation2_FailureSuccess) {
+
+    ASSERT_EQ(ErrorCode::OK, GenerateKey(AuthorizationSetBuilder()
+                                             .RsaSigningKey(2048, 65537)
                                              .Digest(Digest::NONE)
                                              .Padding(PaddingMode::NONE)
                                              .Authorization(TAG_NO_AUTH_REQUIRED)
                                              .Authorization(TAG_TRUSTED_CONFIRMATION_REQUIRED)));
 
     const string message = "12345678901234567890123456789012";
+    const string conf_token = "confirmation token";
+
     EXPECT_EQ(ErrorCode::OK,
               Begin(KeyPurpose::SIGN,
                     AuthorizationSetBuilder().Digest(Digest::NONE).Padding(PaddingMode::NONE)));
     string signature;
     EXPECT_EQ(ErrorCode::NO_USER_CONFIRMATION, Finish(message, &signature));
+        
+    std::vector<uint8_t> input;
+    input.insert(input.end(), conf_token.begin(), conf_token.end());
+    input.insert(input.end(), message.begin(), message.end());
+    
+    std::vector<uint8_t> macKey(32, 0);
+    std::array<uint8_t, 32> hash;
+    unsigned int hashLen = 0;
+    
+    auto result = ::HMAC(EVP_sha256(), macKey.data(), macKey.size(), input.data(), input.size(), hash.data(), &hashLen);
+    EXPECT_TRUE(result != nullptr);
+    std::vector<uint8_t> confToken(hash.begin(), hash.end());
+
+    EXPECT_EQ(ErrorCode::OK,
+              Begin(KeyPurpose::SIGN,
+                    AuthorizationSetBuilder().Digest(Digest::NONE).Padding(PaddingMode::NONE)));
+    
+    AuthorizationSet out_params;
+    string output;
+    string retText;
+    
+    EXPECT_EQ(ErrorCode::OK, Finish(op_handle_, AuthorizationSetBuilder().Authorization(TAG_CONFIRMATION_TOKEN,HidlBuf(confToken)), message, signature,
+                             &out_params, &output));
+    CheckedDeleteKey();
+}
+
+/*
+ * SigningOperationsTest.TrustedConfirmationRequired_HMAC
+ *
+ * Verifies that keymaster rejects signing operations for keys with
+ * TRUSTED_CONFIRMATION_REQUIRED and no valid confirmation token
+ * presented.
+ */
+
+TEST_P(SigningOperationsTest, TrustedConfirmationRequired_HMAC) {
+    
+    ASSERT_EQ(ErrorCode::OK, GenerateKey(AuthorizationSetBuilder()
+                                                 .Authorization(TAG_NO_AUTH_REQUIRED)
+                                                 .HmacKey(128)
+                                                 .Digest(Digest::SHA_2_256)
+						 .Padding(PaddingMode::NONE)
+                                                 .Authorization(TAG_MIN_MAC_LENGTH, 160)
+                                                 .Authorization(TAG_PURPOSE, KeyPurpose::SIGN)
+                                                 .Authorization(TAG_TRUSTED_CONFIRMATION_REQUIRED)))
+	<< "Failed to create HMAC key with digest " ;
+
+	const string conf_token = "confirmation token";
+	const string message = "12345678901234567890123456789012";
+	string signature;
+
+	std::vector<uint8_t> input;
+	input.insert(input.end(), conf_token.begin(), conf_token.end());
+	input.insert(input.end(), message.begin(), message.end());
+	    
+	std::vector<uint8_t> macKey(32, 0);
+	std::array<uint8_t, 32> hash;
+	unsigned int hashLen = 0;
+	    
+	auto result = ::HMAC(EVP_sha256(), macKey.data(), macKey.size(), input.data(), input.size(), hash.data(), &hashLen);
+	EXPECT_TRUE(result != nullptr);
+    std::vector<uint8_t> confToken(hash.begin(), hash.end());
+	    
+	EXPECT_EQ(ErrorCode::OK,
+		      Begin(KeyPurpose::SIGN,
+			    AuthorizationSetBuilder().Digest(Digest::SHA_2_256).Padding(PaddingMode::NONE).Authorization(TAG_MAC_LENGTH, 160)));
+	    
+	AuthorizationSet out_params;
+	string output;
+	string retText;
+	EXPECT_EQ(ErrorCode::OK, Finish(op_handle_, AuthorizationSetBuilder().Authorization(TAG_CONFIRMATION_TOKEN,HidlBuf(confToken)), message, signature,
+			             &out_params, &output));    
+         
+        CheckedDeleteKey();
+    
+}
+
+TEST_P(SigningOperationsTest, TrustedConfirmationRequired_TomanyOperations) {
+    
+    
+        ASSERT_EQ(ErrorCode::OK, GenerateKey(AuthorizationSetBuilder()
+                                                 .Authorization(TAG_NO_AUTH_REQUIRED)
+                                                 .HmacKey(128)
+                                                 .Digest(Digest::SHA_2_256)
+						 .Padding(PaddingMode::NONE)
+                                                 .Authorization(TAG_MIN_MAC_LENGTH, 160)
+                                                 .Authorization(TAG_PURPOSE, KeyPurpose::SIGN)
+                                                 .Authorization(TAG_TRUSTED_CONFIRMATION_REQUIRED)))
+        << "Failed to create HMAC key with digest " ;
+
+        const string conf_token = "confirmation token";
+        const string message = "12345678901234567890123456789012";
+    	string signature;
+    
+	std::vector<uint8_t> input;
+	input.insert(input.end(), conf_token.begin(), conf_token.end());
+	input.insert(input.end(), message.begin(), message.end());
+	    
+	std::vector<uint8_t> macKey(32, 0);
+	std::array<uint8_t, 32> hash;
+	unsigned int hashLen = 0;
+	auto result = ::HMAC(EVP_sha256(), macKey.data(), macKey.size(), input.data(), input.size(), hash.data(), &hashLen);
+    EXPECT_TRUE(result != nullptr);
+	std::vector<uint8_t> confToken(hash.begin(), hash.end());
+	AuthorizationSet out_params;
+	string output;
+	string retText;
+	int max_operations = SecLevel() == SecurityLevel::STRONGBOX ? 4 : 16;
+	OperationHandle op_handles[max_operations];
+	
+   
+	for(int i=0; i< max_operations; i++) {    
+		EXPECT_EQ(ErrorCode::OK,
+		      Begin(KeyPurpose::SIGN, key_blob_
+			    , AuthorizationSetBuilder().Digest(Digest::SHA_2_256).Padding(PaddingMode::NONE).Authorization(TAG_MAC_LENGTH, 160)
+			    , &out_params
+			    , &(op_handles[i])));
+	}
+	
+	EXPECT_EQ(ErrorCode::TOO_MANY_OPERATIONS,
+         Begin(KeyPurpose::SIGN, key_blob_
+			    , AuthorizationSetBuilder().Digest(Digest::SHA_2_256).Padding(PaddingMode::NONE).Authorization(TAG_MAC_LENGTH, 160)
+			    , &out_params, &op_handle_));    
+	
+	for(int i=0; i< max_operations; i++) {
+        	EXPECT_EQ(ErrorCode::OK, Finish(op_handles[i], AuthorizationSetBuilder().Authorization(TAG_CONFIRMATION_TOKEN,HidlBuf(confToken)),
+        				 message, signature,
+			             &out_params, &output));
+        }
+        
+   	EXPECT_EQ(ErrorCode::OK,
+		      Begin(KeyPurpose::SIGN, key_blob_
+			    , AuthorizationSetBuilder().Digest(Digest::SHA_2_256).Padding(PaddingMode::NONE).Authorization(TAG_MAC_LENGTH, 160)
+			    , &out_params
+			    , &op_handle_));		    
+	    
+	
+        CheckedDeleteKey();
+    
 }
 
 /*
